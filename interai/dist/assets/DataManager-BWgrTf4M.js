var c=Object.defineProperty;var l=(o,t,s)=>t in o?c(o,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):o[t]=s;var n=(o,t,s)=>l(o,typeof t!="symbol"?t+"":t,s);class D{constructor(){n(this,"storage",chrome.storage.local)}async saveResume(t){try{await this.storage.set({resume:t})}catch(s){throw console.error("Failed to save resume:",s),s}}async getResume(){try{const t=await this.storage.get("resume");return t.resume?this.deserializeResume(t.resume):null}catch(t){return console.error("Failed to get resume:",t),null}}deserializeResume(t){var s;return{...t,createdAt:t.createdAt?new Date(t.createdAt):new Date,updatedAt:t.updatedAt?new Date(t.updatedAt):new Date,workExperience:(t.workExperience||[]).map(e=>({...e,startDate:e.startDate?new Date(e.startDate):new Date,endDate:e.endDate?new Date(e.endDate):void 0})),education:(t.education||[]).map(e=>({...e,startDate:e.startDate?new Date(e.startDate):new Date,endDate:e.endDate?new Date(e.endDate):void 0})),skills:{...t.skills,certifications:(((s=t.skills)==null?void 0:s.certifications)||[]).map(e=>({...e,dateObtained:e.dateObtained?new Date(e.dateObtained):new Date,expirationDate:e.expirationDate?new Date(e.expirationDate):void 0}))},projects:(t.projects||[]).map(e=>({...e,startDate:e.startDate?new Date(e.startDate):void 0,endDate:e.endDate?new Date(e.endDate):void 0}))}}async saveJobDescription(t){try{const e=(await this.storage.get("jobDescriptions")).jobDescriptions||[],r=e.findIndex(a=>a.id===t.id);r>=0?e[r]=t:e.push(t),await this.storage.set({jobDescriptions:e})}catch(s){throw console.error("Failed to save job description:",s),s}}async getJobDescription(t){try{return((await this.storage.get("jobDescriptions")).jobDescriptions||[]).find(r=>r.id===t)||null}catch(s){return console.error("Failed to get job description:",s),null}}async getAllJobDescriptions(){try{return(await this.storage.get("jobDescriptions")).jobDescriptions||[]}catch(t){return console.error("Failed to get job descriptions:",t),[]}}async saveSession(t){try{const e=(await this.storage.get("sessions")).sessions||[],r=e.findIndex(a=>a.id===t.id);r>=0?e[r]=t:e.push(t),e.length>10&&(e.sort((a,i)=>new Date(i.createdAt).getTime()-new Date(a.createdAt).getTime()),e.splice(10)),await this.storage.set({sessions:e})}catch(s){throw console.error("Failed to save session:",s),s}}async getSession(t){try{return((await this.storage.get("sessions")).sessions||[]).find(r=>r.id===t)||null}catch(s){return console.error("Failed to get session:",s),null}}async getAllSessions(){try{return(await this.storage.get("sessions")).sessions||[]}catch(t){return console.error("Failed to get sessions:",t),[]}}async saveSettings(t){try{const s={...t};s.apiKey,await this.storage.set({settings:s})}catch(s){throw console.error("Failed to save settings:",s),s}}async getSettings(){try{return(await this.storage.get("settings")).settings||null}catch(t){return console.error("Failed to get settings:",t),null}}async deleteTranscripts(t){try{const e=(await this.getAllSessions()).map(r=>({...r,transcript:r.transcript.filter(a=>new Date(a.timestamp)>=t)}));await this.storage.set({sessions:e})}catch(s){throw console.error("Failed to delete transcripts:",s),s}}async clearAllData(){try{await this.storage.clear()}catch(t){throw console.error("Failed to clear data:",t),t}}}export{D};
